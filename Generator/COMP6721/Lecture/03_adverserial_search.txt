Intro to AI
1
Artificial Intelligence:
Adversarial Search
2
Motivation
GO
chess tic-tac-toe
3
Today
â—¼ State Space Search for Game Playing
â‘ MiniMax
â‘ Alpha-beta pruning
â‘ Stochastic Games
â—¼ Where we are today
5
â—¼ Classical application for heuristic search
â‘ simple games: exhaustively searchable
â‘ complex games: only partial search possible
â‘ additional problem: playing against opponent
â—¼ Here, we look at 2-player adversarial games
â‘ win, lose, or tie
Aryan Saxena
6
Types of Games
â—¼ Perfect Information
â‘ A game with the perfect information is that in which agents can
look into the complete board. Agents have all the information about
the game, and they can see each other moves also.
â‘ Examples: Chess, Checkers, Go, etc.
â—¼ Imperfect Information
â‘ Game state only partially observable, choices by opponent are not
visible (hidden)
â‘ Example: Battleship, Stratego, many card games, etc.
7
Types of Games (II)
â—¼ Deterministic games
â‘ No games of chance (e.g., rolling dice)
â‘ Examples: Chess, Tic-Tac-Toe, Go, etc.
â—¼ Non-deterministic games
â‘ Games with unpredictable (random) events (involving chance or luck)
â‘ Example: Backgammon, Monopoly, Poker, etc.
8
Types of Games (III)
â—¼ Zero-Sum Game
â‘ If the total gains of one player are added up, and the
total losses are subtracted, they will sum to zero
(example: cutting a cake)
â‘ A gain by one player must be matched by a loss by the
other player
â‘ One player tries to maximize a single value, the other
player tries to minimize it
â‘ Examples: Checkers, Chess, etc.
â—¼ Non-Zero-Sum Game
â‘ Win-Win or Lose-Lose type games
â‘ Famous example: The Prisonerâ€™s Dilemma
https://en.wikipedia.org/wiki/Prisoner%27s_dilemma
9
â‘ Stochastic games
10
Example: Game of Nim
â—¼ Rules
â‘ 2 players start with a pile of tokens
â‘ move: split (any) existing pile into two non-empty
differently-sized piles
â‘ game ends when no pile can be unevenly split
â‘ player who cannot make his move loses
11
State Space of Game Nim
â—¼ start with one pile of tokens
â—¼ each step has to divide one pile
of tokens into 2 non-empty piles
of different size
â—¼ player without a move left loses
game
source: G. Luger (2005)
12
MiniMax Search
â—¼ Game between two opponents, MIN and MAX
â‘ MAX tries to win, and
â‘ MIN tries to minimize MAXâ€™s score
â—¼ Existing heuristic search methods do not work
â‘ would require a helpful opponent
â‘ Need to incorporate â€œhostileâ€ moves into search strategy
13
Exhaustive MiniMax Search
â—¼ For small games where exhaustive search is feasible
â—¼ Procedure:
1. build complete game tree
2. label each level according to playerâ€™s turn (MAX or MIN)
3. label leaves with a utility function to determine the outcome
of the game
â—¼ e.g., (0, 1) or (-1, 0, 1)
4. propagate this value up:
â—¼ if parent=MAX, give it max value of children
â—¼ if parent=MIN, give it min value of children
5. Select best next move for player at root as the move leading
to the child with the highest value (for MAX) or lowest
values (for MIN)
14
Exhaustive MiniMax for Nim
Bold lines indicate
forced win for MAX
0: win for MIN
1: win for MAX
15
n-ply MiniMax with Heuristic
â—¼ Exhaustive search for interesting games is rarely
feasible
â—¼ Search only to predefined level
â‘ called n-ply look-ahead
â‘ n is number of levels
â—¼ No exhaustive search
â‘ nodes evaluated with heuristics and not win/loss
â‘ indicates best state that can be reached
â‘ horizon effect
â—¼ Games with opponent
â‘ simple strategy: try to maximize difference between
players using a heuristic function e(n)
Heuristic Function for 2-player games
â—¼ simple strategy:
â‘try to maximize difference between MAXâ€™s game and MINâ€™s
â—¼ typically called e(n)
â—¼ e(n) is a heuristic that estimates how favorable a
node n is for MAX
â‘ e(n) > 0 --> n is favorable to MAX
â‘ e(n) < 0 --> n is favorable to MIN
â‘ e(n) = 0 --> n is neutral
16
Choosing a Heuristic Function e(n)
17
18
MiniMax with Fixed Ply Depth
Leaf nodes show the actual heuristic value e(n)
19
Internal nodes show back-up heuristic value
max(2,3) = 3
max(5,9) = 9
â€¦.
20
min(3,9) = 3
min(0,7) = 9
min(2,6) = 2
21
max(3, 0, 2) = 3
22
Best next move
Example: e(n) for Tic-Tac-Toe
â—¼ Possible e(n)
number of rows, columns, and diagonals open for MAX
- number of rows, columns, and diagonals open for MIN
+ , if n is a forced win for MAX
- , if n is a forced win for MIN
e(n) = 8-8 = 0 e(n) = 6-4 = 2 e(n) = 3-3 = 0
23
e(n) =
24
More examplesâ€¦
25
Two-ply MiniMax for Opening Move
Tic-Tac-Toe tree
at horizon = 2
26
Two-ply MiniMax: MAXâ€™s possible 2nd moves
27
Two-ply minimax: MAXâ€™s move at end
28
29
Alpha-Beta Pruning
â—¼ Optimization over MiniMax, that:
â‘ ignores (cuts off, prunes) branches of the tree
that cannot possibly lead to a better solution
â‘ reduces branching factor
â‘ allows deeper search with same effort
30
Alpha-Beta Pruning: Example 1
â—¼ With MiniMax, we look at all possible nodes at the n-ply depth
â—¼ With Î±-Î² pruning, we ignore branches that could not possibly
contribute to the final decision
B will be >= 5
So we can ignore Bâ€™s right
branch, because A must be 3
D will be <= 0
But C will be >= 3
So we can ignore Dâ€™s right
branch
E will be <= 2.
So we can ignore Eâ€™s right
Because C will be 3.
A=min(3, max(5,?)) C=max(3, min(0,?), min(2,?))
Alpha-Beta Pruning Algorithm
31
â—¼ Î± : lower bound on the final backed-up value.
â—¼ Î² : upper bound on the final backed-up value.
â—¼ Alpha pruning:
â‘ eg.  if MAX node's Î± = 6, then the search can prune branches from a MIN
descendant that has a Î² <= 6.
â‘ if child Î² <= ancestor Î± â†’ prune
â‘
â—¼ Beta pruning:
â‘ eg. if a MIN node's Î² = 6, then the search can prune branches from a MAX
descendant that has an Î± >= 6.
â‘ if ancestor Î² <= child Î± â†’ prune
value â‰¥ 6
value â‰¤ 5
incompatibleâ€¦
so stop searching the right branch;
the value cannot come from there!
MAX
MIN
value â‰¤ 6
value â‰¥ 7
b=6ï¡ =-âˆ
ï¡ =7 b=+âˆ
b=+âˆï¡ =6
b=5ï¡ =-âˆ
32
01 function alphabeta(node, depth, Î±, Î², maximizingPlayer)
02      if depth = 0 or node is a terminal node
03          return the heuristic value of node
04      if maximizingPlayer
05          v := -âˆ
06          for each child of node
07              v := max(v, alphabeta(child, depth - 1, Î±, Î², FALSE))
08              Î± := max(Î±, v)
09              if Î² â‰¤ Î±
10                  break (* Î² cut-off *)
11          return v
12      else
13          v := âˆ
14          for each child of node
15              v := min(v, alphabeta(child, depth - 1, Î±, Î², TRUE))
16              Î² := min(Î², v)
17              if Î² â‰¤ Î±
18                  break (* Î± cut-off *)
19          return v
Initial call:
alphabeta(origin, depth, -âˆ, +âˆ, TRUE)
source: http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
Example with tic-tac-toe
33
min level
max level
source: robotics.stanford.edu/~latombe/cs121/2003/home.htm
http://robotics.stanford.edu/~latombe/cs121/winter02/home.htm
e(n) = 2
34
value â‰¤ 2
b=2ï¡ =-âˆ
e(n) = 1e(n) = 2
35
value â‰¤ 2 1
b=2 1ï¡ =-âˆ
value â‰¥ 1
e(n) = 1
value = 1
36
b=+âˆï¡ =1
e(n) = 2 e(n) = -1
value â‰¤ -1
37
b=-1ï¡ =-âˆ
b = 1
child Î² <= ancestor Î± â†’ stop search
38
Max
-------------------------------------------------------------------------------------------------------
Min
--------------------------------------------------------------------------------------------------------
39
Alpha-Beta Pruning: Example 2
source: http://en.wikipedia.org/wiki/File:AB_pruning.svg
â‰¤5
=5 =6
=5
â‰¥5
=7
â‰¤7
=4
â‰¤4 â‰¤4
=3
â‰¥3
=6
â‰¥6
â‰¤6 â‰¤6
â‰¤6
âœ“
x x
âœ“ x
40
Alpha-Beta Pruning: Example 3
41
42
43
<=4
44
<=3
45
46
47
>=3
48
49
<=2
50
prune
51
52
53
54
55
=2
56
57
58
<=5
59
60
>=4
61
62
63
>=2
64
65
=4 <=1
deep cut!
66
=1
<=1
10 nodes explored out of 27
67
Efficiency of Alpha-Beta Pruning
â—¼ Depends on the order of the siblings
â—¼ In worst case:
â‘ alpha-beta provides no pruning
â—¼ In best case:
â‘ branching factor is reduced to its square root
Alpha-Beta: Best ordering
68
Original (arbitrary) game tree
Best ordering for alpha-beta
â—¼ best ordering:
1. children of MIN : smallest node first
2. children of MAX: largest node first
69
70
71
72
73
74
8 nodes explored out of 27
75
Backgammon
source: Russel & Norvig (2010)
Stochastic (Non-Deterministic)
Games
â—¼ Search tree for games of chance
â‘ white can calculate its own legal moves
â‘ but it does not know what black will roll...
â—¼ Idea: add chance nodes to the search tree
â‘ branches indicate possible dice rolls
â‘ each branch labeled with the roll and its probability
(e.g., 1/6 for a single dice roll)
Search Tree for Backgammon
EXPECTIMINIMAX Algorithm
â—¼ Calculating EXPECTIMINIMAX
â‘ Like MiniMax, but using the weighted sum for Chance nodes:
â‘ r is a possible dice roll (or other random event)
â‘ P(r) the probability of the event
â‘ Result(s, r) is the same state s with dice roll result r
â‘ Note: very expensive due to the high branching factor!
â‘ See https://en.wikipedia.org/wiki/Expectiminimax
for the whole algorithm
à·ğ‘ƒ ğ‘Ÿ ğ¸ğ‘¥ğ‘ğ‘’ğ‘ğ‘¡ğ‘–ğ‘šğ‘–ğ‘›ğ‘–ğ‘šğ‘ğ‘¥ ğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘ , ğ‘Ÿ
https://en.wikipedia.org/wiki/Expectiminimax
84
1992-1994 - Checkers:
Tinsley vs. Chinook Marion Tinsley
World champion
for over 40 years
In 2007, Schaeffer announced that checkers was solved,
and anyone playing against Chinook would only be able to draw, never win.
Chinook
Developed by
Jonathan Schaeffer,
professor at the U. of Alberta
1992: Tinsley beat Chinook in 4 games to 2,
with 33 draws.
1994: 6 draws
VS
85
Play against Chinook: http://games.cs.ualberta.ca/cgi-bin/player.cgi?nodemo
http://games.cs.ualberta.ca/cgi-bin/player.cgi?nodemo
1997 - Othello: Murakami vs. Logistello
Logistello beat Murakami by 6 games to 0
Takeshi Murakami
World Othello (aka Reversi) champion
Logistello
developed by Michael Buro
runs on a standard PC
https://skatgame.net/mburo/log.html
(including source code)
86
1997- Chess: Kasparov vs. Deep Blue
Garry Kasparov
50 billion neurons
2 positions/sec
Deep Blue
32 RISC processors
+ 256 VLSI chess engines
200,000,000 pos/sec
Deep Blue wins by 3 wins, 1 loss, and 2 draws
87
2003 - Chess: Kasparov vs. Deep Junior
Match ends in a 3/3 tie!
still 50 billion neurons
still 2 positions/sec
Deep Junior
8 CPU, 8 GB RAM, Win 2000
2,000,000 pos/sec
Available at $100
88
89
2016 â€“ Go: AlphaGo vs Lee Se-dol
â—¼ GO was always considered a much harder game to automate
than chess because of its very high branching factor (35 for
chess vs 250 for Go!)
https://www.theverge.com/2016/3/15/11213518/alphago-deepmind-go-match-5-result
â—¼ In 2016, AlphaGo beat Lee Sedol in a
five-game match of GO.
â—¼ In 2017 AlphaGo beat Ke Jie, the
world No.1 ranked player at the time
â—¼ uses a Monte Carlo tree search
algorithm to find its moves based on
knowledge previously "learned" by deep
learning
90
2017 â€“ AlphaGo Zero & AlphaZero
AlphaGo Zero learned the Game by itself, without input of human
games
â—¼ Became better than all old versions after 40 days of training
â—¼ In the first three days, AlphaGo Zero played 4.9 million games
against itself using reinforcement learning
AlphaZero can learn other
games, like Chess and Shogi
â—¼ In 2018, it beat the then-
best chess program,
Stockfish 8 in a 100-game
tournament
â—¼ Trained using 5,000 tensor
processing units (TPUs), run
on four TPUs and a 44-core
CPU during matches
91
2018 â€“ AlphaZero vs Stockfish 8
Game commentary: https://www.youtube.com/watch?v=nPexHaFL1uo
https://www.youtube.com/watch?v=nPexHaFL1uo
92
